---
title: 本站 - 站点信息
date: 2021-12-30 21:44:18
permalink: /about/website/info/
categories:
  - 关于 - 本站
tags: 
  - 本站
---

::: note

本内容介绍如何搭建本站首页的站点信息，以及每篇文章的浏览量统计。

::: right

2021-12-30 @Young Kbt

:::

[[TOC]]



## 前言

本站的站点信息和文章浏览量是直接修改 Vdoing 主题的源码，有缺陷，那就是升级版本或者按照其他依赖时，重置源码，导致自己修改的被清空。

可以直接在配置文件里添加，但是这样也有缺陷，如统计访问量不及时，必须每次刷新后才能刷新访问量。

![image-20211230215051564](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20211230215117.png)

本站的访问量和文章的浏览量使用了 **不蒜子插件**，也在开发自己的统计项目，也许开发完，就会利用 axious 请求替换插件。

因为不蒜子利用域名来统计访问量，所以本地 localhost 肯定有很多人访问过，所以访问量才会那么多。

官网地址：<http://busuanzi.ibruce.info/>

文档地址：<http://ibruce.info/2015/04/04/busuanzi/>

## 安装依赖

官网推荐引入在线脚本，但是在 VuePress 里，单页面跳转不会重新触发在线脚本，也就不会获取访问量，在线脚本仅在第一次加载页面触发本，或者刷新网页触发。所以会发现从一个文章跳转到另一个文章，另一个文章的浏览量是不会变化的，除非刷新页面。

所以这里使用不蒜子依赖，利用 Vue 的 Watch 监听路由的变化，一旦改变则重新触发不蒜子依赖，从而重新拉取访问量。

安装依赖直接在自己的项目安装即可。

- yarn安装

```sh
yarn add busuanzi.pure.js
```

- npm安装

```sh
npm install busuanzi.pure.js --save
```

## 添加meta

为什么添加 meta 头信息呢，因为在 Chrome 85 版本中，为了保护用户的隐私，默认的 Referrer Policy 则变成了 `strict-origin-when-cross-origin`

所以必须添加 meta，否则文章统计访问量的数据则不正确。

VuePress 在 head.js 添加如下内容：

```js
['meta', { name: 'referrer', content: 'no-referrer-when-downgrade' }],
```

普通页面在 head 标签添加如下内容：

```html
<meta name="referrer" content="no-referrer-when-downgrade">
```

## 添加代码

### 模板

这里先提供一个模板代码，即通用代码：

```vue
<template>
  <div class="busuanzi">
    <span id="busuanzi_container_site_pv" style="display:none">
      本站总访问量
      <span id="busuanzi_value_site_pv"></span>次
      <span class="post-meta-divider">|</span>
    </span>
    <span id="busuanzi_container_site_uv" style="display:none">
      本站访客数
      <span id="busuanzi_value_site_uv"></span>人
    </span>
  </div>
</template>
 
<script>
let script;
export default {
  mounted() {
    script = require("busuanzi.pure.js");
  },
  // 监听，当路由发生变化的时候执行
  watch: {
    $route(to, from) {
      if (to.path != from.path) {
        script.fetch();
      }
    }
  }
};
</script>
```



我是在哪添加的呢？

- 首页的站点信息直接在本地写
- 每一篇文章的浏览量在源码里加入

目前没有想到好办法在本地操作每一篇文章的布局，所以只能去源码里添加浏览量代码，菜鸟的我还在想办法。

首先进入 Vdoing 的本地主题，即 vuePress-theme-vdoing 目录中。（如果你曾获取过完整版的 Vdoing，那么它会存在，否则再去获取，提取出来）

### 文章浏览量代码

这里已经假设你进入到了 Voding 的源码里，然后进入 components 目录下，打开 ArticleInfo.vue 文件

![image-20211230222521774](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20211230222523.png)

大概在 108 行代码处，添加如下内容：

```html
<div class="view iconfont icon-view" title="浏览量">
    <span id="busuanzi_container_page_pv" style="display:none">
        <a href="javascript:;" id="busuanzi_value_page_pv"></a>
    </span>
</div>
```

如图：

![image-20220101191315313](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220101191316.png)

### 添加路由监听代码

这一步很重要，它能让你跳转页面的时候，获取该页面的历史访问量，并加上你这次的访问量。

进入 layouts 目录下，打开 Layout.vue 文件

![image-20211230222755789](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20211230222756.png)

首先大概在 118 行处，引入 busuanzi 插件

```js
const busuanzi = require("busuanzi.pure.js");
```

如图：

![image-20220101191508276](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220101191509.png)

然后大概在 282 行处，添加如下内容：（位于 Watch 钩子里）

```js
$route(to, from) {
    if (to.path != from.path) {
        busuanzi.fetch();
    }
}
```

如图：

![image-20211230222912527](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20211230222913.png)

### 网站信息工具代码

添加网站信息需要的计算代码、获取字数代码等工具类。

这一步开始不需要在源码里操作，我们回到自己的本地项目中。

首先进入 docs 目录下的 .vuepress 目录，创建 `webSiteInfo` 文件夹

![image-20220101192402636](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220101192403.png)

然后在 webSiteInfo 目录下创建 `readFile.js` 文件，这个文件用于 <mark>统计文章数目</mark> 和 <mark>网站总字数</mark>。

添加如下内容：

```js
const fs = require('fs'); // 文件模块
const path = require('path'); // 路径模块
const log = console.log
const docsRoot = path.join(__dirname, '..', '..', '..', 'docs'); // docs文件路径

// 获取所有的 md 文档，可以排除指定目录下的文档
function readFileList(excludeFiles = [''], dir = docsRoot, filesList = []) {
  const files = fs.readdirSync(dir);
  files.forEach((item, index) => {
    let filePath = path.join(dir, item);
    const stat = fs.statSync(filePath);
    excludeFiles.forEach((excludeFile) => {
      if (stat.isDirectory() && item !== '.vuepress' && item !== '@pages' && item !== excludeFile) {
        readFileList(excludeFiles, path.join(dir, item), filesList);  //递归读取文件
      } else {
        if (path.basename(dir) !== 'docs') { // 过滤 docs目录级下的文件

          const fileNameArr = path.basename(filePath).split('.')
          let name = null, type = null;
          if (fileNameArr.length === 2) { // 没有序号的文件
            name = fileNameArr[0]
            type = fileNameArr[1]
          } else if (fileNameArr.length === 3) { // 有序号的文件
            name = fileNameArr[1]
            type = fileNameArr[2]
          } else { // 超过两个‘.’的
            log(chalk.yellow(`warning: 该文件 "${filePath}" 没有按照约定命名，将忽略生成相应数据。`))
            return
          }
          if (type === 'md') { // 过滤非 md 文件
            filesList.push({
              name,
              filePath
            });
          }
        }
      }
    });
  });
  return filesList;
}
// 可以排除某个目录下的 md 文档字数
function readFileWords(excludeFiles = ['']) {
  const filesList = readFileList(excludeFiles);
  var wordCount = 0;
  filesList.forEach((item) => {
    const content = getContent(item.filePath);
    var len = counter(content);
    wordCount += len[0] + len[1];
  });
  if (wordCount < 1000) {
    return wordCount;
  }
  return Math.round(wordCount / 100) / 10 + 'k';
}


function getContent(filePath) {
  return fs.readFileSync(filePath, 'utf-8');
}

function counter(content) {
  const cn = (content.match(/[\u4E00-\u9FA5]/g) || []).length;
  const en = (content.replace(/[\u4E00-\u9FA5]/g, '').match(/[a-zA-Z0-9_\u0392-\u03c9\u0400-\u04FF]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af\u0400-\u04FF]+|[\u00E4\u00C4\u00E5\u00C5\u00F6\u00D6]+|\w+/g) || []).length;
  return [cn, en];
}

module.exports = {
  readFileList,
  readFileWords,
}
```

接着继续在该目录下创建第二个文件 `utils.js`，该文件用于计算 <mark>已运行时间</mark> 和 <mark>最后活动时间</mark>。

添加如下内容：

```js
// 日期格式化(只获取年月日)
export function dateFormat (date) {
  if (!(date instanceof Date)) {
    date = new Date(date)
  }
  return `${date.getUTCFullYear()}-${zero(date.getUTCMonth() + 1)}-${zero(date.getUTCDate())}`
}

// 小于10补0
export function zero (d) {
  return d.toString().padStart(2, '0')
}

/**
 * 获取两个日期相差多少天
 * @param {*} lowDate 旧日期
 * @param {*} upDate  新日期
 * @returns 相差多少天
 */
 export function getDay (lowDate, upDate) {
  if(!upDate) {
    upDate = lowDate;
    lowDate = new Date();
  }
  lowDate = dateFormat(lowDate);
  upDate = dateFormat(upDate);
  return parseInt(Math.abs(new Date(lowDate) - new Date(upDate)) / (1000 * 60 * 60 * 24));
}
```

目前就两个文件，最终效果如图：

![image-20220101192823081](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220101192824.png)

### 站点信息代码

这一步的文件目录不能随便移动，因为该目录是 Vuepress 规定的。

首先进入 docs 目录下的 .vuepress 目录，创建 components 文件夹。

![image-20220101193210129](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220101193212.png)



创建一个 vue 文件：`WebInfo.vue`，这就是首页的站点信息模块。

并添加如下内容：

```vue
<template>
  <!-- Young Kbt -->
  <div class="web-info card-box">
    <div class="webinfo-title">
      <i
        class="iconfont icon-award"
        style="font-size: 0.875rem; font-weight: 900; width: 1.25em"
      ></i>
      <span>站点信息</span>
    </div>
    <div class="webinfo-item">
      <div class="webinfo-item-title">文章数目：</div>
      <div class="webinfo-content">{{ mdFileCount }} 篇</div>
    </div>

    <div class="webinfo-item">
      <div class="webinfo-item-title">已运行时间：</div>
      <div class="webinfo-content">{{ createToNowDay }} 天</div>
    </div>

    <div class="webinfo-item">
      <div class="webinfo-item-title">本站总字数：</div>
      <div class="webinfo-content">{{ totalWords }} 字</div>
    </div>

    <div class="webinfo-item">
      <div class="webinfo-item-title">最后活动时间：</div>
      <div class="webinfo-content">
        {{ lastActiveDate > 1 ? lastActiveDate + " 天前" : "今天" }}
      </div>
    </div>

    <div class="webinfo-item">
      <div class="webinfo-item-title">本站被访问了：</div>
      <div class="webinfo-content">
        <span id="busuanzi_container_site_pv">
          <span id="busuanzi_value_site_pv"></span> 次
        </span>
      </div>
    </div>

    <div class="webinfo-item">
      <div class="webinfo-item-title">您的访问排名：</div>
      <div class="webinfo-content busuanzi">
        <span id="busuanzi_container_site_uv">
          <span id="busuanzi_value_site_uv"></span>
        </span>
      </div>
    </div>
  </div>
</template>

<script>
import { getDay } from "../webSiteInfo/utils";
const busuanzi = require("busuanzi.pure.js");
export default {
  data() {
    return {
      // Young Kbt
      mdFileCount: 0, // markdown 文档总数
      createToNowDay: 0, // 博客创建时间距今多少天
      lastActiveDate: 0, // 最后活动时间
      totalWords: 0, // 本站总字数
    };
  },
  mounted() {
    // Young Kbt
    if (Object.keys(this.$themeConfig.blogInfo).length > 0) {
      const { blogCreate, mdFileCountType, totalWords, moutedEvent } =
        this.$themeConfig.blogInfo;
      this.createToNowDay = getDay(blogCreate);
      if (mdFileCountType != "archives") {
        this.mdFileCount = mdFileCountType.length;
      } else {
        this.mdFileCount = this.$filterPosts.length;
      }
      this.totalWords = totalWords;
      // 最后一次活动时间
      this.lastActiveDate = getDay(this.$sortPosts[0].lastUpdated);
      mountedWebInfo(moutedEvent || ".tags-wrapper");
      getViewCouter();
    }
  },
};

function mountedWebInfo(moutedEvent = ".tags-wrapper") {
  let interval = setInterval(() => {
    const tagsWrapper = document.querySelector(moutedEvent);
    const webInfo = document.querySelector(".web-info");
    if (tagsWrapper && webInfo) {
      if (!isSiblilngNode(tagsWrapper, webInfo)) {
        tagsWrapper.parentNode.insertBefore(webInfo, tagsWrapper.nextSibling);
        clearInterval(interval);
      }
    }
  }, 200);
}

function isSiblilngNode(element, siblingNode) {
  if (element.parentNode == siblingNode.parentNode) {
    return true;
  } else {
    return false;
  }
}

function getViewCouter() {
  var i = 0;
  let interval = setInterval(() => {
    i++;
    const pv = document.querySelector("#busuanzi_value_site_pv");
    const uv = document.querySelector("#busuanzi_value_site_uv");
    if (pv.innerText == "" && uv.innerText == "") {
      // 获取访问量
      busuanzi.fetch();
      if(i > 10 * 30){
        clearInterval(interval);  // 半分钟无法获取，则取消获取
      }
    } else {
      clearInterval(interval);
    }
  }, 100);
}
</script>

<style>
.web-info {
  font-size: 0.875rem;
  padding: 0.95rem;
}
.webinfo-title {
  text-align: center;
  color: #888;
  font-weight: bold;
  padding: 0 0 10px 0;
}
.webinfo-item {
  padding: 8px 0 0;
  margin: 0;
}
.webinfo-item-title {
  display: inline-block;
}
.webinfo-content {
  display: inline-block;
  float: right;
}
</style>
```

最终效果如图：

![image-20220101193400080](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220101193401.png)

创建好了该 vue 文件，我们需要使用它，找到 docs 目录下的 index.md

![image-20220101193622169](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220101193623.png)



移到最下方，添加如下内容：

```vue
<ClientOnly>
  <WebInfo/>
</ClientOnly>
```

熟悉 vue 脚手架的人应该都有疑惑，那就是使用 vue 组件前，不需要引入吗？就像 `import xxx from 'xx/xx.vue'` 一样。

其实 Vuepress 会自动扫描 .vuepress 是否有 components 目录，如果有并且里面有 .vue 文件，则自动将它们全局注册，所以直接在任何 md 文档按照文件名引入即可。

这也告诉我们，可以直接在 components 目录写 vue 文件，然后按照文件名在任意 md 文档引入，即可看到效果。。

### 站点信息配置

上面都按照步骤写好代码、使用文件了，那么就可以配置我们的站点信息。

进入到 docs 目录下的 .vuepress 的 config 目录，打开 themeConfig.js 文件。

引入之前写好的工具代码：

```js
const { readFileList, readFileWords } = require('../webSiteInfo/readFile');
```

在 `module.exports` 里添加如下内容：

```js
blogInfo: {
    blogCreate: '2021-10-19', // 博客创建时间
    mdFileCountType: 'archives',  // 文档数。archives 获取归档的文档数（默认），数组 readFileList(['xx']) 排除 xx 目录（可多个），获取其他目录的文档数。
    totalWords: readFileWords(['00.目录页']),  // 本站文档总字数。readFileWords(['xx']) 排除 xx 目录（可多个），获取其他目录的文章字数，默认排除了 .vuepress 和 @page 目录
    moutedEvent: '.tags-wrapper'   // 挂载在哪个元素后面，指的是挂载在哪个兄弟元素的后面，默认是热门标签 '.tags-wrapper' 后面
},
```

如图：

![image-20220101194441291](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220101194442.png)

**blogCreate**

- 类型：`string`
- 默认值：null
- 格式：yyyy-mm-dd

博客创建时间，如果不添加时间，页面上显示 0 天。

**mdFileCountType**

- 类型：`string` | `readFileList([])`
- 默认值：archives

文章数目，如果不添加内容，页面上显示归档的文章数目。

readFileList是一个 js 文件，需要引入，参数是 <mark>目录的全名</mark>，最终效果会 <mark>排除该目录里的文章数</mark>，可多选，逗号隔开。

**totalWords**

- 类型：`readFileWords([])`
- 默认值：null

本站文档总字数，如果不添加内容，页面上显示 0 字。

readFileWords 是一个 js 文件，需要引入，参数是目录的全名，最终效果会 <mark>排除该目录里的文章字数</mark>，可多选，逗号隔开。

**moutedEvent**

- 类型：`string`
- 默认值：.tags-wrapper

选择挂载的元素属性（id、class ......），该模块会挂载到该元素后面，形成兄弟元素。

## 结尾

如果大家有方法能将文章浏览量代码插入到每一个文章页里，并且全局监听路由变化，请在评论区留言，谢谢！
