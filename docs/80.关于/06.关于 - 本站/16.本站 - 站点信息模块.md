---
title: 本站 - 站点信息
date: 2021-12-30 21:44:18
permalink: /about/website/info/
categories:
  - 关于 - 本站
tags: 
  - 本站
---

::: note

本内容介绍如何搭建本站首页的站点信息，以及每篇文章的浏览量统计。

::: right

2021-12-30 @Young Kbt

:::

[[TOC]]



## 前言

本站的站点信息和文章浏览量是直接修改 Vdoing 主题的源码，有缺陷，那就是升级版本或者按照其他依赖时，重置源码，导致自己修改的被清空。

可以直接在配置文件里添加，但是这样也有缺陷，如统计访问量不及时，必须每次刷新后才能刷新访问量。

![image-20220102230719391](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220102230720.png)

本站的访问量和文章的浏览量使用了 **不蒜子插件**，也在开发自己的统计项目，也许开发完，就会利用 axious 请求替换插件。

因为不蒜子利用域名来统计访问量，所以本地 localhost 肯定有很多人访问过，所以访问量才会那么多。

官网地址：<http://busuanzi.ibruce.info/>

文档地址：<http://ibruce.info/2015/04/04/busuanzi/>

## 安装依赖

官网推荐引入在线脚本，但是在 VuePress 里，单页面跳转不会重新触发在线脚本，也就不会获取访问量，在线脚本仅在第一次加载页面触发本，或者刷新网页触发。所以会发现从一个文章跳转到另一个文章，另一个文章的浏览量是不会变化的，除非刷新页面。

所以这里使用不蒜子依赖，利用 Vue 的 Watch 监听路由的变化，一旦改变则重新触发不蒜子依赖，从而重新拉取访问量。

安装依赖直接在自己的项目安装即可。

- yarn安装

```sh
yarn add busuanzi.pure.js
```

- npm安装

```sh
npm install busuanzi.pure.js --save
```

## 添加meta

为什么添加 meta 头信息呢，因为在 Chrome 85 版本中，为了保护用户的隐私，默认的 Referrer Policy 则变成了 `strict-origin-when-cross-origin`

所以必须添加 meta，否则文章统计访问量的数据则不正确。

VuePress 在 head.js 添加如下内容：

```js
['meta', { name: 'referrer', content: 'no-referrer-when-downgrade' }],
```

普通页面在 head 标签添加如下内容：

```html
<meta name="referrer" content="no-referrer-when-downgrade">
```

## 添加在线图标

这里使用的是阿里的矢量库

地址：<https://www.iconfont.cn/>

添加了三个图标

![image-20220103005041682](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220103005042.png)

如果你不想去添加，那么可以使用我的图标项目网址，在 head.js 文件添加如下内容：

```js
['link', { rel: 'stylesheet', href: 'https://at.alicdn.com/t/font_3077305_wawne43ztng.css' }],
```

![image-20220103005210888](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220103005212.png)

## 添加代码

### 模板

这里先提供一个模板代码，即通用代码：

```vue
<template>
  <div class="busuanzi">
    <span id="busuanzi_container_site_pv" style="display:none">
      本站总访问量
      <span id="busuanzi_value_site_pv"></span>次
      <span class="post-meta-divider">|</span>
    </span>
    <span id="busuanzi_container_site_uv" style="display:none">
      本站访客数
      <span id="busuanzi_value_site_uv"></span>人
    </span>
  </div>
</template>
 
<script>
let script;
export default {
  mounted() {
    script = require("busuanzi.pure.js");
  },
  // 监听，当路由发生变化的时候执行
  watch: {
    $route(to, from) {
      if (to.path != from.path) {
        script.fetch();
      }
    }
  }
};
</script>
```

我是在哪添加的呢？

- 首页的站点信息直接在本地的 components 目录写
- 每一篇文章的浏览量在本地的 enhanceApp.js 文件写

### 网站信息工具代码

添加网站信息需要的计算代码、获取字数代码等工具类。

首先进入 docs 目录下的 .vuepress 目录，创建 `webSiteInfo` 文件夹

![image-20220101192402636](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220101192403.png)

然后在 webSiteInfo 目录下创建 `readFile.js` 文件，这个文件用于 <mark>统计文章数目</mark> 和 <mark>网站总字数</mark>。

添加如下内容：

```js
const fs = require('fs'); // 文件模块
const path = require('path'); // 路径模块
const matter = require('gray-matter'); // FrontMatter解析器 https://github.com/jonschlinkert/gray-matter
const chalk = require('chalk') // 命令行打印美化
const log = console.log
const docsRoot = path.join(__dirname, '..', '..', '..', 'docs'); // docs文件路径

/**
 * 获取本站的文章数据
 * 获取所有的 md 文档，可以排除指定目录下的文档
 */
function readFileList(excludeFiles = [''], dir = docsRoot, filesList = []) {
  const files = fs.readdirSync(dir);
  files.forEach((item, index) => {
    let filePath = path.join(dir, item);
    const stat = fs.statSync(filePath);
    if(!(excludeFiles instanceof Array)){
      log(chalk.yellow(`error: 传入的参数不是一个数组。`))
    }
    excludeFiles.forEach((excludeFile) => {
      if (stat.isDirectory() && item !== '.vuepress' && item !== '@pages' && item !== excludeFile) {
        readFileList(excludeFiles, path.join(dir, item), filesList);  //递归读取文件
      } else {
        if (path.basename(dir) !== 'docs') { // 过滤 docs目录级下的文件

          const fileNameArr = path.basename(filePath).split('.')
          let name = null, type = null;
          if (fileNameArr.length === 2) { // 没有序号的文件
            name = fileNameArr[0]
            type = fileNameArr[1]
          } else if (fileNameArr.length === 3) { // 有序号的文件
            name = fileNameArr[1]
            type = fileNameArr[2]
          } else { // 超过两个‘.’的
            log(chalk.yellow(`warning: 该文件 "${filePath}" 没有按照约定命名，将忽略生成相应数据。`))
            return
          }
          if (type === 'md') { // 过滤非 md 文件
            filesList.push({
              name,
              filePath
            });
          }
        }
      }
    });
  });
  return filesList;
}
/**
 * 获取本站的文章总字数
 * 可以排除某个目录下的 md 文档字数
 */
function readTotalFileWords(excludeFiles = ['']) {
  const filesList = readFileList(excludeFiles);
  var wordCount = 0;
  filesList.forEach((item) => {
    const content = getContent(item.filePath);
    var len = counter(content);
    wordCount += len[0] + len[1];
  });
  if (wordCount < 1000) {
    return wordCount;
  }
  return Math.round(wordCount / 100) / 10 + 'k';
}
/**
 * 获取每一个文章的字数
 * 可以排除某个目录下的 md 文档字数
 */
function readEachFileWords(excludeFiles = ['']) {
    const filesListWords = [];
    const filesList = readFileList(excludeFiles);
    filesList.forEach((item) => {
      const content = getContent(item.filePath);
      var len = counter(content);
      var wordsCount = 0;
      wordsCount = len[0] + len[1];
      if (wordsCount >= 1000) {
        wordsCount = Math.round(wordsCount / 100) / 10 + 'k';
      }
      // fileMatterObj => {content:'剔除frontmatter后的文件内容字符串', data:{<frontmatter对象>}, ...}
      const fileMatterObj = matter(content, {});
      const matterData = fileMatterObj.data;
      filesListWords.push({...item, wordsCount, ...matterData});
    });
    return filesListWords;
}

/**
 * 读取文件内容
 */
function getContent(filePath) {
  return fs.readFileSync(filePath, 'utf8');
}
/**
 * 获取文件内容的字数
 * cn：中文
 * en：一整句英文（没有空格隔开的英文为 1 个）
 */
function counter(content) {
  const cn = (content.match(/[\u4E00-\u9FA5]/g) || []).length;
  const en = (content.replace(/[\u4E00-\u9FA5]/g, '').match(/[a-zA-Z0-9_\u0392-\u03c9\u0400-\u04FF]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af\u0400-\u04FF]+|[\u00E4\u00C4\u00E5\u00C5\u00F6\u00D6]+|\w+/g) || []).length;
  return [cn, en];
}

module.exports = {
  readFileList,
  readTotalFileWords,
  readEachFileWords,
}
```

接着继续在该目录下创建第二个文件 `utils.js`，该文件用于计算 <mark>已运行时间</mark> 和 <mark>最后活动时间</mark>。

添加如下内容：

```js
// 日期格式化(只获取年月日)
export function dateFormat(date) {
  if (!(date instanceof Date)) {
    date = new Date(date)
  }
  return `${date.getUTCFullYear()}-${zero(date.getUTCMonth() + 1)}-${zero(date.getUTCDate())}`
}

// 小于10补0
export function zero(d) {
  return d.toString().padStart(2, '0')
}

/**
 * 获取两个日期相差多少天
 */
export function dayDiff(startDate, endDate) {
  if (!endDate) {
    endDate = startDate;
    startDate = new Date();
  }
  startDate = dateFormat(startDate);
  endDate = dateFormat(endDate);
  let day = parseInt(Math.abs(new Date(startDate) - new Date(endDate)) / (1000 * 60 * 60 * 24));
  return day;
}

/**
 * 计算相差多少年/月/日/时/分/秒
 */
export function timeDiff(startDate, endDate) {
  if (!endDate) {
    endDate = startDate;
    startDate = new Date();
  }
  if (!(startDate instanceof Date)) {
    startDate = new Date(startDate);
  }
  if (!(endDate instanceof Date)) {
    endDate = new Date(endDate);
  }
  // 计算时间戳的差
  const diffValue = parseInt((Math.abs(endDate - startDate) / 1000));

  if (diffValue == 0) {
    return '刚刚';
  } else if (diffValue < 60) {
    return diffValue + ' 秒';
  } else if (parseInt(diffValue / 60) < 60) {
    return parseInt(diffValue / 60) + ' 分钟';
  } else if (parseInt(diffValue / (60 * 60)) < 24) {
    return parseInt(diffValue / (60 * 60)) + ' 小时';
  } else if (parseInt(diffValue / (60 * 60 * 24)) < getDays(startDate.getMonth, startDate.getFullYear)) {
    return parseInt(diffValue / (60 * 60 * 24)) + ' 天';
  } else if (parseInt(diffValue / (60 * 60 * 24 * getDays(startDate.getMonth, startDate.getFullYear))) < 12) {
    return parseInt(diffValue / (60 * 60 * 24 * getDays(startDate.getMonth, startDate.getFullYear))) + ' 个月';
  } else {
    return parseInt(diffValue / (60 * 60 * 24 * getDays(startDate.getMonth, startDate.getFullYear) * 12)) + ' 年';
  }
}

/**
 * 判断当前月的天数（28、29、30、31）
 */
function getDays(mouth, year) {
  let days = 30
  if (mouth === 2) {
    days = year % 4 === 0 ? 29 : 28
  } else if (mouth === 1 || mouth === 3 || mouth === 5 || mouth === 7 || mouth === 8 || mouth === 10 || mouth === 12) {
    // 月份为：1,3,5,7,8,10,12 时，为大月.则天数为 31；
    days = 31
  }
  return days
}

/**
 * 已运行时间低于一天显示时分秒
 * 目前该函数没有使用，低于一天直接显示不到一天
 */
function getTime(startDate, endDate){
  if (day < 0) {
    let hour = parseInt(Math.abs(new Date(startDate) - new Date(endDate)) / (1000 * 60 * 60));
    if (hour > 0) {
      let minute = parseInt(Math.abs(new Date(startDate) - new Date(endDate) - hour * 60 * 60 * 1000) / (1000 * 60));
      if (minute > 0) {
        let second = parseInt(Math.abs(new Date(startDate) - new Date(endDate) - hour * 60 * 60 * 1000 - minute * 60 * 1000) / (1000));
        if (second != 0) {
          return hour + ' 小时 ' + minute + ' 分钟 ' + second + ' 秒';
        } else {
          return hour + ' 小时 ' + minute + ' 分钟 ';
        }
      } else {
        return hour + ' 小时 ';
      }
    } else {
      let minute = parseInt(Math.abs(new Date(startDate) - new Date(endDate) - hour * 60 * 60 * 1000) / (1000 * 60));
      if (minute > 0) {
        let second = parseInt(Math.abs(new Date(startDate) - new Date(endDate) - hour * 60 * 60 * 1000 - minute * 60 * 1000) / (1000));
        if (second != 0) {
          return + minute + ' 分钟 ' + second + ' 秒';
        } else {
          return minute + ' 分钟 ';
        }
      } else {
        return parseInt(Math.abs(new Date(startDate) - new Date(endDate) - hour * 60 * 60 * 1000 - minute * 60 * 1000) / (1000)) + ' 秒 ';
      }
    }
  }
}
```

目前就两个文件，最终效果如图：

![image-20220101192823081](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220101192824.png)

### 站点信息代码

这一步的文件目录不能随便移动，因为该目录是 Vuepress 规定的。

首先进入 docs 目录下的 .vuepress 目录，创建 components 文件夹

![image-20220101193210129](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220101193212.png)



创建一个 vue 文件：`WebInfo.vue`，这就是首页的站点信息模块。

并添加如下内容：

```vue
<template>
  <!-- Young Kbt -->
  <div class="web-info card-box">
    <div class="webinfo-title">
      <i
        class="iconfont icon-award"
        style="font-size: 0.875rem; font-weight: 900; width: 1.25em"
      ></i>
      <span>站点信息</span>
    </div>
    <div class="webinfo-item">
      <div class="webinfo-item-title">文章数目：</div>
      <div class="webinfo-content">{{ mdFileCount }} 篇</div>
    </div>

    <div class="webinfo-item">
      <div class="webinfo-item-title">已运行时间：</div>
      <div class="webinfo-content">
        {{ createToNowDay != 0 ? createToNowDay + ' 天' : "不到一天" }}
      </div>
    </div>

    <div class="webinfo-item">
      <div class="webinfo-item-title">本站总字数：</div>
      <div class="webinfo-content">{{ totalWords }} 字</div>
    </div>

    <div class="webinfo-item">
      <div class="webinfo-item-title">最后活动时间：</div>
      <div class="webinfo-content">
        {{ lastActiveDate == "刚刚" ? "刚刚" : lastActiveDate + "前" }}
      </div>
    </div>

    <div class="webinfo-item">
      <div class="webinfo-item-title">本站被访问了：</div>
      <div class="webinfo-content">
        <span id="busuanzi_container_site_pv">
          <span id="busuanzi_value_site_pv" class="web-site-pv"></span> 次
        </span>
      </div>
    </div>

    <div class="webinfo-item">
      <div class="webinfo-item-title">您的访问排名：</div>
      <div class="webinfo-content busuanzi">
        <span id="busuanzi_container_site_uv">
          <span id="busuanzi_value_site_uv" class="web-site-uv"></span> 名
        </span>
      </div>
    </div>
  </div>
</template>

<script>
import { dayDiff, timeDiff } from "../webSiteInfo/utils";
export default {
  data() {
    return {
      // Young Kbt
      mdFileCount: 0, // markdown 文档总数
      createToNowDay: 0, // 博客创建时间距今多少天
      lastActiveDate: "", // 最后活动时间
      totalWords: 0, // 本站总字数
    };
  },
  mounted() {
    // Young Kbt
    if (Object.keys(this.$themeConfig.blogInfo).length > 0) {
      const {
        blogCreate,
        mdFileCountType,
        totalWords,
        moutedEvent,
        eachFileWords,
      } = this.$themeConfig.blogInfo;
      this.createToNowDay = dayDiff(blogCreate);
      if (mdFileCountType != "archives") {
        this.mdFileCount = mdFileCountType.length;
      } else {
        this.mdFileCount = this.$filterPosts.length;
      }
      if (totalWords == "archives" && eachFileWords) {
        let archivesWords = 0;
        eachFileWords.forEach((itemFile) => {
          if (itemFile.wordsCount < 1000) {
            archivesWords += itemFile.wordsCount;
          } else {
            let wordsCount = itemFile.wordsCount.slice(
              0,
              itemFile.wordsCount.length - 1
            );
            archivesWords += wordsCount * 1000;
          }
        });
        this.totalWords = Math.round(archivesWords / 100) / 10 + "k";
      } else if(totalWords == "archives"){
        this.totalWords = 0;
        console.log("如果 totalWords 使用 archives，必须传入 eachFileWords");
      }else{
        this.totalWords = totalWords;
      }
      // 最后一次活动时间
      this.lastActiveDate = timeDiff(this.$sortPosts[0].lastUpdated);
      mountedWebInfo(moutedEvent);
    }
  },
};
/**
 * 挂载站点信息模块
 */
function mountedWebInfo(moutedEvent = ".tags-wrapper") {
  let interval = setInterval(() => {
    const tagsWrapper = document.querySelector(moutedEvent);
    const webInfo = document.querySelector(".web-info");
    if (tagsWrapper && webInfo) {
      if (!isSiblilngNode(tagsWrapper, webInfo)) {
        tagsWrapper.parentNode.insertBefore(webInfo, tagsWrapper.nextSibling);
        clearInterval(interval);
      }
    }
  }, 200);
}
/**
 * 挂载在兄弟元素后面
 */
function isSiblilngNode(element, siblingNode) {
  if (element.parentNode == siblingNode.parentNode) {
    return true;
  } else {
    return false;
  }
}
/**
 * 首页的统计量
 * 该方法移到了 enhanceApp.js 文件
 */
function getIndexViewCouter() {
  // require 会获取一次访问量
  //const busuanzi = require("busuanzi.pure.js");
  var i = 0;
  var defaultCouter = "9999";
  // 如果 require 没有获取成功，则手动获取
  setTimeout(() => {
    let interval = setInterval(() => {
      const indexUv = document.querySelector(".web-site-pv");
      const indexPv = document.querySelector(".web-site-uv");
      if (indexPv || indexUv) {
        i++;
        if (i > 1 * 10) {
          indexPv.innerText = defaultCouter;
          indexUv.innerText = defaultCouter;
          clearInterval(interval); // 10 秒后无法获取，则取消获取
        }
        if (indexPv.innerText == "" && indexUv.innerText == "") {
          // 手动获取访问量
          //busuanzi.fetch();
        } else {
          clearInterval(interval);
        }
      } else {
        clearInterval(interval);
      }
    }, 3000);
  }, 3000);
}
</script>

<style>
.web-info {
  font-size: 0.875rem;
  padding: 0.95rem;
}
.webinfo-title {
  text-align: center;
  color: #888;
  font-weight: bold;
  padding: 0 0 10px 0;
}
.webinfo-item {
  padding: 8px 0 0;
  margin: 0;
}
.webinfo-item-title {
  display: inline-block;
}
.webinfo-content {
  display: inline-block;
  float: right;
}
</style>
```

最终效果如图：

![image-20220101193400080](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220101193401.png)

创建好了该 vue 文件，我们需要使用它，找到 docs 目录下的 index.md

![image-20220101193622169](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220101193623.png)



移到最下方，添加如下内容：

```vue
<ClientOnly>
  <WebInfo/>
</ClientOnly>
```

熟悉 vue 脚手架的人应该都有疑惑，那就是使用 vue 组件前，不需要引入吗？就像 `import xxx from 'xx/xx.vue'` 一样。

其实 Vuepress 会自动扫描 .vuepress 是否有 components 目录，如果有并且里面有 .vue 文件，则自动将它们全局注册，所以直接在任何 md 文档按照文件名引入即可。

这也告诉我们，可以直接在 components 目录写 vue 文件，然后按照文件名在任意 md 文档引入，即可看到效果。。

### 文章浏览量和字数代码

首先进入 docs 目录下的 .vuepress 目录，打开 enhanceApp.js 文件。该文件监听路由，然后触发文章浏览量和字数的代码

我这里提供我的代码，如果该文件有你曾写的代码，在后面追加我的即可。

```js
export default ({
  Vue, // VuePress 正在使用的 Vue 构造函数
  options, // 附加到根实例的一些选项
  router, // 当前应用的路由实例
  siteData, // 站点元数据
  isServer // 当前应用配置是处于 服务端渲染 或 客户端
}) => {
  if (!isServer) {
    router.beforeEach((to, from, next) => {
      // 路由切换，触发百度的 pv 统计
      if (typeof _hmt != "undefined") {
        if (to.path) {
          _hmt.push(["_trackPageview", to.path]);
        }
      }
      next();

      setTimeout(() => {
        // 首页或者文章页的访问量
        if (to.path == '/') {
          getIndexViewCouter();
        } else if (to.path != '/' && to.path != from.path) { // # 号也会触发路由变化，排除掉
          // 刷新页面或进入新的页面后，如果原来位置的内容还存在，则删除掉，最后重新插入渲染
          removeElement('.page-view-js');
          removeElement('.page-view');
          removeElement('.book-words');
          siteData.pages.forEach((itemPage) => {
            if (itemPage.path == to.path) {
              if (itemPage.frontmatter.article == undefined || itemPage.frontmatter.article) {  // 排除掉 article 为 false 的文章
                const { eachFileWords, pageView } = siteData.themeConfig.blogInfo;
                // 下面两个 if 可以调换位置，从而让文章的浏览量和字数内容交换
                if (eachFileWords) {
                  eachFileWords.forEach((itemFile) => {
                    if (itemFile.permalink == itemPage.frontmatter.permalink) {
                      addPageWordsCount(itemFile.wordsCount);
                    }
                  });
                }
                if (pageView || pageView == undefined) {
                  addPageView();
                  // 挂载成功需要一点时间
                  setTimeout(() => {
                    getPageViewCouter();
                  }, 500);
                }

                return;
              }
            }
          })
        }
      }, 200);
    })
  }
}
/**
 * 如果元素存在，则删除
 */
function removeElement(selector) {
  var element = document.querySelector(selector);
  if (element) {
    element.parentNode.removeChild(element);
  }
}
/**
 * 首页的统计量
 */
function getIndexViewCouter() {
  // require 会获取一次访问量
  const busuanzi = require("busuanzi.pure.js");
  var i = 0;
  var defaultCouter = '9999';
  // 如果 require 没有获取成功，则手动获取
  // 但是容易产生访问量叠加，如果只需要第一次获取数据（可能获取失败），可注释掉，此内容是第一次获取失败后，重新获取访问量，可能导致访问量再次 + 1
  // 取决于访问人的网络，以及 setTimeout 的时间（需求调节）
  setTimeout(() => {
    let interval = setInterval(() => {
      const indexUv = document.querySelector(".web-site-pv");
      const indexPv = document.querySelector(".web-site-uv");
      if (indexPv || indexUv) {
        i++;
        if (i > 1 * 10) {
          indexPv.innerText = defaultCouter;
          indexUv.innerText = defaultCouter;
          clearInterval(interval);  // 10 秒后无法获取，则取消获取
        }
        if (indexPv.innerText == "" && indexUv.innerText == "") {
          // 手动获取访问量
          busuanzi.fetch();
        } else {
          clearInterval(interval);
        }
      } else {
        clearInterval(interval);
      }
    }, 3000);
  }, 3000);
}
/**
 * 文章页的访问量
 */
function getPageViewCouter() {
  // require 会获取一次访问量
  const busuanzi = require("busuanzi.pure.js");
  var i = 0;
  var defaultCouter = '9999';
  // 如果 require 没有获取成功，则手动获取
  // 但是容易产生访问量叠加，如果只需要第一次获取数据（可能获取失败），可注释掉，此内容是第一次获取失败后，重新获取访问量，可能导致访问量再次 + 1
  // 取决于访问人的网络，以及 setTimeout 的时间（需求调节）
  setTimeout(() => {
    let interval = setInterval(() => {
      const pageView = document.querySelector('.view-data');
      if (pageView) {
        i++;
        if (i > 1 * 10) {
          pageView.innerText = defaultCouter;
          clearInterval(interval);  // 10 秒后无法获取，则取消获取
        }
        if (pageView.innerText == "") {
          // 手动获取访问量
          busuanzi.fetch();
        } else {
          clearInterval(interval);
        }
      } else {
        clearInterval(interval);
      }
    }, 3000);
  }, 3000);
}
/**
 * 添加浏览量元素
 */
function addPageView() {
  // 创建访问量的元素
  let template = document.createElement('div');
  template.title = '浏览量';
  template.className = 'page-view iconfont icon-view';
  template.style.float = 'left';
  template.style.marginLeft = '20px';
  template.style.fontSize = '0.8rem';
  template.innerHTML = '<span id="busuanzi_container_page_pv" style="display: none; margin-left: 3px"><a style="color: #888" href="javascript:;" id="busuanzi_value_page_pv" class="view-data"></a></span>';

  mountedView(template);
}
/**
 * 添加当前文章页的字数元素
 */
function addPageWordsCount(wordsCount) {
  if (wordsCount) {
    let template = document.createElement('div');
    template.title = '文章字数';
    template.className = 'book-words iconfont icon-book';
    template.style.float = 'left';
    template.style.marginLeft = '20px';
    template.style.fontSize = '0.8rem';
    template.innerHTML = `<a href="javascript:;" style="margin-left: 3px; color: #888">${wordsCount}</a>`;
    mountedView(template);
  }
}
/**
 * 挂载目标到页面上
 */
function mountedView(template, moutedParentEvent = '.articleInfo-wrap > .articleInfo > .info') {
  var i = 0;
  let interval = setInterval(() => {
    i++;
    const parentElement = document.querySelector(moutedParentEvent);
    if (parentElement) {
      if (!isMountedView(template, parentElement)) {
        parentElement.appendChild(template);
        clearInterval(interval);
      }
    } else if (i > 1 * 10) {  // 10 秒后清除
      clearInterval(interval);
    }
  }, 1000);
}
/**
 * 目标是否已经挂载在页面上
 */
function isMountedView(element, parentElement) {
  if (element.parentNode == parentElement) {
    return true;
  } else {
    return false;
  }
}
```

### 站点信息配置

上面都按照步骤写好代码、使用文件了，那么就可以配置我们的站点信息。

进入到 docs 目录下的 .vuepress 的 config 目录，打开 themeConfig.js 文件。

引入之前写好的工具代码：

```js
const { readFileList, readTotalFileWords, readEachFileWords } = require('../webSiteInfo/readFile');
```

在 `module.exports` 里添加如下内容：

```js
// 博客站点信息（首页）
blogInfo: {
	blogCreate: '2021-10-19', // 博客创建时间
	mdFileCountType: 'archives',  // 开启文档数。1. archives 获取归档的文档数（默认）。2. 数组 readFileList(['xx']) 排除 xx 目录（可多个，可不传参数），获取其他目录的文档数。温馨提示：readFileList() 获取 docs 下所有的 md 文档
	totalWords: 'archives',  // 开启本站文档总字数。1. archives 获取归档的文档数（使用 archives 条件：传入 eachFileWords，否则报错）。2. readTotalFileWords(['xx']) 排除 xx 目录（可多个，可不传参数），获取其他目录的文章字数。无默认值
	eachFileWords: readEachFileWords(),  // 开启每个文章页的字数。readEachFileWords(['xx']) 排除 xx 目录（可多个，可不传参数），获取其他目录的文章字数，无默认值。readEachFileWords() 方法默认排除了 article 为 false 的文章
	moutedEvent: '.tags-wrapper',   // 首页的站点模块挂载在某个元素后面（支持各种选择器），指的是挂载在哪个兄弟元素的后面，默认是热门标签 '.tags-wrapper' 下面，提示 '.categories-wrapper' 在文章分类下面。'.blogger-wrapper' 在博客头像模块下面
	pageView: true,  // 开启文章页的浏览量统计，默认 true（开启）
},
```

如图：

![image-20220102231908167](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/%E5%85%B3%E4%BA%8E/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/20220102231909.png)

**blogCreate**

- 类型：`string`
- 默认值：null
- 格式：yyyy-mm-dd

博客创建时间，如果不添加时间，页面上显示 0 天。

**mdFileCountType**

- 类型：`string` | `readFileList()`
- 参数：数组
- 默认值：archives

文章数目，如果不添加内容，页面上显示归档的文章数目。

readFileList 是一个 js 文件，需要引入，参数是 <mark>目录的全名</mark>，最终效果会 <mark>排除该目录里的文章数</mark>，可多选，可不传参数，逗号隔开。

温馨提示：readFileList() 不传参数能获取 docs 下所有的 md 文档（除了 `.vuepress` 和 `@pages` 目录下的文档）。

**totalWords**

- 类型：`string` | `readFileWords()`
- 参数：数组
- 默认值：null

本站文档总字数，如果不添加内容，页面上显示 0 字。

`string` 仅支持 'archives'，并且该类型有条件：必须使用 eachFileWords，否则报错。

readFileWords 是一个 js 文件，需要引入，参数是目录的全名，最终效果会 <mark>排除该目录里的文章字数</mark>，可多选，可不传参数，逗号隔开。

**eachFileWords**

- 类型：`readEachFileWords()`
- 参数：数组
- 默认值：null

开启每个文章页的字数。如果不添加内容，则不开启。

readEachFileWords(['xx']) 排除 xx 目录（可多个，可不传参数），获取其他目录的文章字数，无默认值。

readEachFileWords() 方法默认排除了 article 为 false 的文章。

**moutedEvent**

- 类型：`string`
- 默认值：.tags-wrapper

选择挂载的元素属性，支持多种选择器（id、class ......），该模块会挂载到该元素后面，形成兄弟元素。（仅支持首页的元素）。

温馨提示：'.categories-wrapper' 会挂载在文章分类下面。'.blogger-wrapper' 会挂载在博客头像模块下面，默认是热门标签 '.tags-wrapper' 下面。

**pageView**

- 类型 `boolean`
- 默认值：true

开启文章页的浏览量统计，默认 true（开启）。

## 结尾

如果大家有更好的方法，评论区告诉我，谢谢！
