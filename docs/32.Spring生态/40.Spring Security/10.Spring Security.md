---
title: Spring Security 源码分析
date: 2021-10-22 00:42:15
permalink: /spring-security/code/
categories:
  - Spring生态
tags: 
  - Spring
  - 权限管理
---


[[TOC]]

## Spring Security认证流程


![流程](https://note.youdao.com/yws/api/personal/file/WEB48dbc1393cc0fafa53216fb5e28b9491?method=download&shareKey=6c32d1e998dcf1160142ecd403899780)

## UsernamePasswordAuthenticationFilter过滤器

### 概念

​	`UsernamePasswordAuthenticationFilter`：用于处理基于表单的登录请求，从表单中 获取用户名和密码。默认情况下处理来自 /login 的请求。从表单中获取用户名和密码 时，默认使用的表单 name 值为 `username` 和 `password`，这两个值可以通过设置这个 过滤器的 `usernameParameter` 和 `passwordParameter `两个参数的值进行修改。

### 图例流程（具体看源码，对应步骤看更好理解）

1. 当用户进行表单登录，且提交为post时，表单信息会经过`UsernamePasswordAuthenticationFilter`过滤器，进行身份验证

2. 过滤器使用`attempAuthentication`方法进行身份认证，认证成功或失败后返回`Authentication`对象，认证成功的话，该对象封装了用户信息

    <Strong>attempAuthentication（身份封装方法）过程：</Strong>

       1. 获取表单的用户名和密码，默认是username和password，以及post提交，不是这些请求会抛出异常

       2. 将username和password进行封装成`Authentication`对象，此时该对象是<Strong style="color:blue">未认证</Strong>的，`Authentication`也包括了请求信息，如`sessionId`等

          <Strong>Authentication类</Strong>

          ```java
          Collection<? extends GrantedAuthority> getAuthorities();// 用户的权限集合
          Object getCredentials();// 用户的密码
          Object getDetails();// 请求携带的一些属性信息，如sessionId，remoteAddress
          Object getPrincipal();// 未认证时为前端传来的用户名，认证成功后为封装认证用户信息的UserDetails对象
          boolean isAuthenticated();// 是否被认证了（true：认证成功，false：认证失败）
          //设置是否被认证了（true：已认证，false：未认证）
          void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;
          ```

       3. 调用`ProviderManager`类的`authenticate()`方法，传入<Strong style="color:red">未认证</Strong>的`Authentication`对象，进行认证（`UsernamePasswordAuthenticationToken`是`Authentication`的子类），<Strong style="color:red">--认证成功</Strong>后返回`Authentication`对象，该对象封装了用户信息

          ```java
          // 使用前端传来的username和password构造Authentication对象，标记该对象未认证
          UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);
          // 该方法内部将request请求的内容封装到Authentication对象里，如sessionId
          setDetails(request, authRequest);
          // 调用ProviderManager类的authenticate()方法，传入未认证的Authentication对象，进行认证
          return this.getAuthenticationManager().authenticate(authRequest);
          ```

          <Strong>UsernamePasswordAuthenticationToken类</Strong>（两个构造器）

          1. 第一个构造器用于封装未认证的用户信息，上方代码块的构造器就是这个

              ```java
              public UsernamePasswordAuthenticationToken(Object principal, Object credentials) {
                  super(null);
                  this.principal = principal;
                  this.credentials = credentials;
                  setAuthenticated(false);
              }
              ```

          2. 第二个构造器用于封装认证成功的用户信息

              ```java
              public UsernamePasswordAuthenticationToken(Object principal, Object credentials,
                                                         Collection<? extends GrantedAuthority> authorities) {
                  super(authorities);
                  this.principal = principal;
                  this.credentials = credentials;
                  super.setAuthenticated(true); // must use super, as we override
              }
              ```

          <Strong>ProviderManager类的authenticate（身份认证方法）过程</Strong>

          1. 获取传入的`Authentication`对象，即`UsernamePasswordAuthenticationToken.class`封装的对象

          2. 获取认证方式列表的迭代器（即官方或者用户自定义的认证方式都会放在这个迭代器里）

          3. 判断迭代器的认证方式是否适用传来的`Authentication`对象

          4. 是，则<Strong style="color:blue">委托</Strong>`DaoAuthenticationProvider`的`authenticate`方法进行验证

              ```java
              Authentication result = null;
              ......
              result = provider.authenticate(authentication);//result是Authentication类的对象
              ```

              1. 该方法内部<Strong style="color:blue">关联</Strong>`UserDetailsService`类，该类的一个方法(`loadUserByUsername`)去数据库查询用户是否存在
              2. 存在则封装为`UserDetails`接口的`User`实现类对象，并<Strong style="color:blue">返回</Strong>该`User`对象
              3. 返回到`ProviderManager`时，再次把User对象<Strong style="color:blue">封装</Strong>为<Strong style="color:red">已认证</Strong>的`Authentication`对象，就是上方代码块的`result`

          5. 成功，则返回一个<Strong style="color:red">已认证</Strong>的`Authentication`对象（上方的`User`类的再次封装），将之前传入的<Strong style="color:red">未认证</Strong>的`Authentication`对象的`details`信息（用户权限信息等）拷贝一份到<Strong style="color:red">已认证</Strong>的`Authentication`对象中

          6. 失败，适用父类`AuthenticationManager`进行验证，如果还是失败，则返回失败的异常信息

          7. 成功后，返回`Authentication`对象，对应上方红字的<Strong style="color:red">--认证成功</Strong>，再返回到过滤器中

3. 执行完`attempAuthentication`方法后，获得`Authentication`对象，并调用`doFilter`方法，进入`AbstractAuthenticationProcessingFilter`类中，该类处理认证成功或者认证失败的后续动作。

<hr>

## AbstractAuthenticationProcessingFilter过滤器

处理认证成功或者认证失败的后续动作，并且将认证成功的用户信息存入上下文里，框架随时根据上下文的用户信息进行权限控制

1. 如果认证成功，`doFilter`方法调用一个方法进入认证成功的处理器：`sucessfulAuthentication`方法，失败则调用另一个方法进入认证失败的处理器：`unsucessfulAuthentication`方法

    ​	<Strong>sucessfulAuthentication方法</Strong>

    1. 将认证成功的用户信息对象`Authentication`对象封装到`SecurityContext`对象里，然后该对象存入`SecurityContextHolder`上下文里
    2. rememberMe的处理	
    3. 发布认证成功的事件
    4. 调用认证成功的处理器方法：`onAuthenticationSuccess`，该方法在`AuthenticationSuccessHandler`类里，需要我们继承实现

       <Strong>unsucessfulAuthentication方法</Strong>

    1. 清除该线程在`SecurityContextHolder`中对应的`SecurityContext`对象
    2. rememberMe的处理
    3. 调用认证失败的处理器方法：`onAuthenticationFailure`，该方法在`AuthenticationFailureHandler`类里，需要我们继承实现

<hr>

## SecurityContextPersistenceFilter过滤器

​	前面提到过，在 UsernamePasswordAuthenticationFilter 过滤器认证成功之后，会在AbstractAuthenticationProcessingFilter过滤器的认证成功的处理方法中将已认证的用户信息对象 Authentication 封装进 SecurityContext，并存入 SecurityContextHolder。之后，响应会通过 SecurityContextPersistenceFilter 过滤器。

​	该过滤器的位置在所有过滤器的最前面，请求到来先进它，响应返回最后一个通过它，所以在该过滤器中处理已认证的用户信息对象 Authentication 与 Session 绑定。 认证成功的响应通过 SecurityContextPersistenceFilter 过滤器时，会从 SecurityContextHolder 中取出封装了已认证用户信息对象 Authentication 的 SecurityContext，放进 Session 中。当请求再次到来时，请求首先经过该过滤器，该过滤器会判断当前请求的 Session 是否存有 SecurityContext 对象，如果有则将该对象取出再次放入 SecurityContextHolder 中，之后该请求所在的线程获得认证用户信息，后续的资源访问不需要进行身份认证；当响应再次返回时，该过滤器同样从 SecurityContextHolder 取出 SecurityContext 对象，放入 Session 中

## ExceptionTranslationFilter过滤器

​	该过滤器是用于处理异常的，不需要我们配置，对于前端提交的请求会直接放行，捕获后续抛出的异常并进行处理，例如：权限访问限制

<hr>

## FilterSecurityInterceptor 过滤器

​	FilterSecurityInterceptor 是过滤器链的最后一个过滤器，根据资源权限配置来判断当前请求是否有权限访问对应的资源。如果 访问受限会抛出相关异常，最终所抛出的异常会由前一个过滤器

<hr>

## 实现代码

1. token的管理类，token由JWT头（JWT生成等）、有效负载（用户信息等）、签名（自定义字符串等）组成

    ```Java
    @Component
    public class TokenManager {
        
        //指定token生命时长
        private long tokenLife = 24 * 60 * 60 * 1000;
        //指定编码和解码的字符串，即签名
        private String tokenSignKey = "123456";
        
        //1、使用jwt根据用户名生成token
        public String createToken(String username){
            String token = Jwts.builder().setSubject(username) // token的主体部分：用户信息
                    .setExpiration(new Date(System.currentTimeMillis() + tokenLife)) // token的有效时长：一天
                    .signWith(SignatureAlgorithm.HS512, tokenSignKey).compressWith(CompressionCodecs.GZIP).compact();// token的签名
            return token;
        }
        
        //2、根据token字符串获得token信息
        public String getTokenInfoFromToken(String token){
            String userInfo = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token).getBody();
            return userInfo;
        }
        
        //2、根据token信息获得用户信息
        public String getUserInfoFromToken(String token){
          return getTokenInfoFromToken(token).getSubject();
        }
        
        //2、根据token信息获得时长
        public String getExpirationFromToken(String token){
          return getTokenInfoFromToken(token).getExpiration();
        }
        
        //3.删除token
        public void deleteToken(String token){
            
        }
    }
    ```

    <hr>

2. 自定义密码加密

    ```java
    @Component
    public class DefaultPasswordEncoder implements PasswordEncoder {
    
        /**
         * 重写加密
         * @param rawPassword 传入密码
         * @return 加密的密码
         */
        @Override
        public String encode(CharSequence rawPassword) {
            return "kele" + rawPassword;
        }
    
        /**
         * 密码比对
         * @param rawPassword 传入密码
         * @param encodedPassword 已经加密的密码 
         * @return true or false
         */
        @Override
        public boolean matches(CharSequence rawPassword, String encodedPassword) {
            return encodedPassword.equals("kele" + rawPassword);
        }
    }
    ```

    <hr>

3. 未授权统一处理

    ```java
    public class UnAuthEntryPoint implements AuthenticationEntryPoint {
    
        @Override
        public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
            System.out.println("未授权操作");
        }
    }
    ```

    <hr>

4. 退出登录后删除Token，并且在数据库删除相关信息

    ```java
    @Component
    public class TokenLogoutHandler implements LogoutHandler {
        private TokenManager tokenManager;
        private RedisTemplate redisTemplate;
    
        public TokenLogoutHandler(TokenManager tokenManager, RedisTemplate redisTemplate) {
            this.tokenManager = tokenManager;
            this.redisTemplate = redisTemplate;
        }
    
        // 1.退出的操作：删除token
        @Override
        public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {
            // 1.从请求头header里获取token
            String token = request.getHeader("token");
            // 2.如果token不为空，则删除token
            if(token != null){
                tokenManager.deleteToken(token);
            }
        }
        
        // 2.数据库的相关信息也删除
        public void deleteInfoFromDabase(String token){
            // 调用mapper层，传入token，删除相关信息
            
        }
        
    }
    ```

    <hr>

5. 用户登录成功，生成Token，存入数据库，登录失败返回失败结果，（判断用户成功或者失败看第六步）

    ```java
    public class TokenLoginFilter extends UsernamePasswordAuthenticationFilter {
        private TokenManager tokenManager;
        private AuthenticationManager authenticationManager;
        private RedisTemplate redisTemplate;
        
        public TokenLoginFilter(AuthenticationManager authenticationManager,TokenManager tokenManager,RedisTemplate redisTemplate) {
            this.authenticationManager = authenticationManager;
            this.tokenManager = tokenManager;
            this.redisTemplate = redisTemplate;
        }
    
        /**
         * 用户登录时，处理请求
         * 1. 获取用户操作的表单信息
         * 2. 进行存入权限封装的类里
         */
        @Override
        public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
            try {
                //通过请求的流获取信息，存入User里
                MyUser user = new ObjectMapper().readValue(request.getInputStream(), MyUser.class);
                return authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword(),new ArrayList<>()));
            } catch (IOException e) {
                e.printStackTrace();
            }
            return null;
        }
    
        /**
         * 获取权限封装的类
         * 登录成功则生成token，并把相关信息存入数据库
         * 相关信息指的是，用户名，密码，权限信息
         */
        @Override
        protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {
            // 获取授权的用户信息
            UserDetails user = (UserDetails) authResult.getPrincipal();
            String token = tokenManager.createToken(user.getUsername());
            //调用mapper层，存入用户信息
            redisTemplate.opsForValue().set(user.getUsername(), user.getAuthorities());
            //返回token
            System.out.println("返回登陆成功token" + token + "，存入请求头里");
        }
    
        @Override
        protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
            System.out.println("登录失败的操作，不如返回失败信息和code");
        }
    }
    ```

6. 第五步的`authenticationManager.authenticate`的内部实现，自定义类继承UserDetailsService，重写方法，进行数据库的交互，用户名和密码判断是否正确

    ```java
    @Component("MyUserDetailsService")
    public class MyUserDetailsService implements UserDetailsService {
    
        @Autowired
        private UserInfoDao userDao;
        
        @Override
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            User user = null;
            if(username != null){
                //找到数据库的用户信息，必须有三个字段（用户名，密码，角色名称）
                UserInfo userInfo = userDao.findUserByUsername(username);
                if(userInfo != null){
                    //创建GrantedAuthority的List集合，用于存储GrantedAuthority
                    List<GrantedAuthority> grantedAuthorities = new ArrayList<>();
                    //创建单个GrantedAuthority，用户存储用户信息
                    GrantedAuthority grantedAuthority = new SimpleGrantedAuthority(userInfo.getRole());
                    //存储进去
                    grantedAuthorities.add(grantedAuthority);
                    // 创建User实例，该User是security的User，需要传入三个参数，用户名，密码，角色集合
                    user = new User(userInfo.getUsername(), userInfo.getPassowrd(), grantedAuthorities);
                    
                }
            }
            return user;
        }
    }
    
    ```

    

7. 登录成功后，进行权限认证（认证成功将用户信息存入上下文），源码已经实现，不需要自己手动配置

    ```java
    public class TokenAuthFilter extends BasicAuthenticationFilter {
        
        private TokenManager tokenManager;
        private RedisTemplate redisTemplate;
        
        public TokenAuthFilter(AuthenticationManager authenticationManager,TokenManager tokenManager,RedisTemplate redisTemplate) {
            super(authenticationManager);
            this.tokenManager = tokenManager;
            this.redisTemplate = redisTemplate;
        }
    
        //将权限存入上下文中
        @Override
        protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
            super.doFilterInternal(request, response, chain);
            //获取当前认证成功的用户权限信息
            UsernamePasswordAuthenticationToken authentication = getAuthentication(request);
            //判断是否有权限信息，有则封装成UsernamePasswordAuthenticationToken类，并放到权限上下文中
            if(authentication != null){
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
            chain.doFilter(request, response);
        }
        
        //通过请求获取请求头的token
        public UsernamePasswordAuthenticationToken getAuthentication(HttpServletRequest request){
            String token = request.getHeader("token");
            if(token == null || "".equals(token)){
                String username = tokenManager.getUserInfoFromToken(token);
                List<String> permissionValueList = (List<String>) redisTemplate.opsForValue().get(username);
                Collection<GrantedAuthority> authorities = new ArrayList<>();
                for (String p : permissionValueList) {
                    authorities.add(new SimpleGrantedAuthority(p));
                }
                return new UsernamePasswordAuthenticationToken(username, token,authorities);
            }
            return null;
        }
    }
    ```

8. 权限认证成功的处理器重写

    ```java
    @Component
    public class MySuccessHandler implements AuthenticationSuccessHandler {
        /**
         * 
         * @param request 请求
         * @param response 响应
         * @param authentication spring security框架验证用户信息成功后的封装类
         */
        @Override
        public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
            // 登录的用户信息验证成功后执行的方法
            response.setContentType("text/json;charset=utf-8");
            PrintWriter pw = response.getWriter();
            pw.println("{\"msg\":\"登录成功！\"}");
            pw.flush();
            pw.close();
        }
    }
    ```

8. 权限认证失败的处理器重写

    ```java
    @Component
    public class MyFailHandler implements AuthenticationFailureHandler {
        /**
         * 
         * @param request 请求
         * @param response 响应
         */
        @Override
        public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
            // 登录的用户信息验证失败后执行的方法
            response.setContentType("text/json;charset=utf-8");
            PrintWriter pw = response.getWriter();
            pw.println("{\"msg\":\"登录失败！\"}");
            pw.flush();
            pw.close();
        }
    }
    ```

9. 核心配置类，前面八步写完，不放到核心配置类里，等于白写

    ```java
    @Configuration
    public class TokenWebSecurityConfig extends WebSecurityConfigurerAdapter {
        
        private TokenManager tokenManager;
        private RedisTemplate redisTemplate;
        private DefaultPasswordEncoder defaultPasswordEncoder;
        private UserDetailsService userDetailsService;
    
        @Autowired
        public TokenWebSecurityConfig(TokenManager tokenManager,
                                      RedisTemplate redisTemplate, DefaultPasswordEncoder defaultPasswordEncoder,
                                      @Qualifier("userDetailsServiceImpl") UserDetailsService userDetailsService) {
            this.tokenManager = tokenManager;
            this.redisTemplate = redisTemplate;
            this.defaultPasswordEncoder = defaultPasswordEncoder;
            this.userDetailsService = userDetailsService;
        }
    
        /**
         * 核心配置
         */
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            
            http.exceptionHandling()
                .authenticationEntryPoint(new UnAuthEntryPoint()) //没有权限访问的处理
                .and().authorizeRequests() // 开启认证
                .anyRequest().authenticated()// 任何请求需要认证
                .and().logout().logoutUrl("/logout") // 退出操作
                .addLogoutHandler(new TokenLogoutHandler(tokenManager,redisTemplate)) // 退出后token的操作
                // 权限认证处理类
                .and().addFilter(new TokenAuthFilter(authenticationManager(),tokenManager,redisTemplate))
               	// 添加自定义的过滤器，即用户登录后token的创建
                .addFilter(new TokenLoginFilter(authenticationManager(),tokenManager,redisTemplate)).httpBasic()
                .and().csrf().disable();
        }
    
        /**
         * 调用userDetailsService和密码处理
         */
        @Override
        protected void configure(AuthenticationManagerBuilder auth) throws Exception {
            auth.userDetailsService(userDetailsService).passwordEncoder(defaultPasswordEncoder);
        }
    
        /**
         * 不进行认证的路径设置，可以直接访问
         */
        @Override
        public void configure(WebSecurity web) throws Exception {
            web.ignoring().antMatchers("/api/*");
        }
    }
    
    ```




## JWT流程

1. 登录时，在controller获得用户名和密码，调用service层的登录方法

    ```java
    @RequestMapping(value = "/authentication/login", method = RequestMethod.POST)
    public String createToken( String username,String password ) throws AuthenticationException {
        return authService.login( username, password ); // 登录成功会返回JWT Token给用户
    }
    ```

2. service层先把用户名和密码封装为`UsernamePasswordAuthenticationToken`对象，然后使用`AuthenticationManager`的`authenticate`方法传入该对象，进行验证，返回值为`Authentication`对象，并把该对象存入上下文里，接着去数据库根据用户名获取用户信息和角色信息，存入`UserDetails`对象并返回，接着根据对象生成token，返回给前端

    ```java
    @Autowired
    private AuthenticationManager authenticationManager;
    public String login(String username, String password) {
        UsernamePasswordAuthenticationToken upToken = new UsernamePasswordAuthenticationToken( username, password );
        final Authentication authentication = authenticationManager.authenticate(upToken);
        SecurityContextHolder.getContext().setAuthentication(authentication);
        final UserDetails userDetails = userDetailsService.loadUserByUsername( username );
        final String token = jwtTokenUtil.generateToken(userDetails);
        return token;
    }
    ```

3. 写一个工具类，用于生成token，根据token获取用户信息、时长，刷新token，验证token是否过期等操作

    ```java
    public class JwtTokenUtils implements Serializable {
        private static final long serialVersionUID = -5625635588908941275L;
    
        private static final String CLAIM_KEY_USERNAME = "sub";
        private static final String CLAIM_KEY_CREATED = "created";
    
        // 生成token
        public String generateToken(UserDetails userDetails) {
            Map<String, Object> claims = new HashMap<>();
            claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());
            claims.put(CLAIM_KEY_CREATED, new Date());
            return generateToken(claims);
        }
    
        // 验证token
        public boolean validateToken(String token, UserDetails userDetails) {
            String username = getUserNameFromToken(token);
            return  !isTokenExpired(token);
        }
        // 刷新token
        public String refreshToken(String token){
            Claims claims = getClaimsFromToken(token);
            claims.put(CLAIM_KEY_CREATED,new Date());
            return generateToken(claims);
        }
        // 验证token是否失效
        public boolean isTokenExpired(String token){
            Date expireDate = getExpiredDateFromToken(token);
            return expireDate.before(new Date());
        }
        // 从token中获取过期时间
        public Date getExpiredDateFromToken(String token) {
            Claims claims = getClaimsFromToken(token);
            return claims.getExpiration();
        }
        // 从token中获取用户名
        public String getUserNameFromToken(String token){
            String username;
            try{
                Claims claims = getClaimsFromToken(token);
                username = claims.getSubject();
            } catch (Exception e) {
                username = null;
            }
            return username;
        }
        // 从token中获取荷载
        private Claims getClaimsFromToken(String token){
            Claims claims = null;
            try {
                claims = Jwts.parser()
                        .setSigningKey(Const.SECRET)
                        .parseClaimsJws(token)
                        .getBody();
            } catch (Exception e){
                e.printStackTrace();
            }
            return claims;
        }
        
        // 生成过期时间
        private Date generateExpirationDate() {
            return new Date(System.currentTimeMillis()+Const.EXPIRATION_TIME*1000);
        }
        // 根据荷载生成token
        String generateToken(Map<String, Object> claims) {
            return Jwts.builder()
                    .setClaims(claims)
                    .setExpiration(generateExpirationDate())
                    .signWith(SignatureAlgorithm.HS512, Const.SECRET )
                    .compact();
        }
    }
    ```

4. 写一个过滤器，每次用户访问页面都会获取请求头，判断请求题是否有token，token是否过期，如果都符合，则从token获取用户名，去数据库获取用户的信息，并封装为`UsernamePasswordAuthenticationToken`对象存入上下文，只有存入上下文，security框架才不会拦截

    ```java
    public class Const {
    
      public static final long EXPIRATION_TIME = 432_000_000;     // 5天(以毫秒ms计)
      public static final String SECRET = "CodeSheepSecret";      // JWT密码
      public static final String TOKEN_PREFIX = "Bearer";         // Token前缀
      public static final String HEADER_STRING = "Authorization"; // 存放Token的Header Key
    }
    
    ```

    ```java
    public class JwtFilter extends OncePerRequestFilter {
        @Autowired
        private UserDetailsService userDetailsService;
    
        @Autowired
        private JwtTokenUtils jwtTokenUtil;
        @Override
        protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {
            // 确认是否能根据key拿到value
            String authHeader = httpServletRequest.getHeader( Const.HEADER_STRING );
            // 判断登录用户的token不为空和是Bearer开头的
            if (authHeader != null && authHeader.startsWith( Const.TOKEN_PREFIX )) {
                // 取到token
                final String authToken = authHeader.substring( Const.TOKEN_PREFIX.length() );
                // 从用户请求携带的token获取用户名，能取到证明token除了时间以外都合法了
                String username = jwtTokenUtil.getUserNameFromToken(authToken);
                // token 存在用户名但没有认证的
                if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                    UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
                    // 根据userDetails验证了token是否有效（验证时间是否过期和当前用户名是否匹 配）
                    if (jwtTokenUtil.validateToken(authToken, userDetails)) {
                        // 我们的token，框架是不认识的，token有效就转化构建 UsernamePasswordAuthenticationToken表示认证通过和进行相关授权
                        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                            userDetails, null, userDetails.getAuthorities());
                        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(
                            httpServletRequest));
                        // 设置了认证主体，到UsernamePasswordAuthenticationFilter就不会拦 截，因为你应该带有了它的token
                        SecurityContextHolder.getContext().setAuthentication(authentication);
                    }
                }
            }
            // 继续执行其他过滤器
            filterChain.doFilter(httpServletRequest, httpServletResponse);
        }
    }
    ```

5. ，在核心配置类，把4的过滤器放入security的过滤器之前按，这样security不会拦截

    ```java
     protected void configure( HttpSecurity httpSecurity ) throws Exception {
       	// ......
         httpSecurity
             .addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter.class);
         httpSecurity.headers().cacheControl();
     }
    ```

    

## 总结

正常security项目流程：

1. 登录时，与数据库交互，判断登录是否成功的类（自定义类继承UserDetailsService，重写loadUserByUsername方法）
2. 登录成功后的处理类（自定义类继承AuthenticationSuccessHandler，重写onAuthenticationSuccess方法）
3. 登录失败后的处理类（自定义类继承AuthenticationFailureHandler，重写onAuthenticationFailure方法）
4. 退出登录时的处理类（自定义类继承LogoutHandler，重写logout方法）
5. 退出登录成功后的处理类（自定义类继承onLogoutSuccess，重写onLogoutSuccess方法），第四步和这一步其实可以选择一个写即可，一般退出登录都会成功
6. 未授权统一处理类（自定义类继承AuthenticationEntryPoint，重写commence方法）
7. 最重要的类，配置核心类：
  	1. 自定义类继承WebSecurityConfigurerAdapter，
 	2. 重写configure(HttpSecurity http)，统一把前面的步骤放入spring security框架
 	3. 重写configure(AuthenticationManagerBuilder auth) ，把第一步与数据库交互的类放入spring security框架，框架自动与数据库交互
 	4. 重写configure(WebSecurity web)方法，设置不进行认证的路径设置，这些路径都可以直接访问，一般是静态资源



需要token的security项目流程：

​	1. 自定义Token管理类，根据用户信息生成token，解析token获取用户信息或者token时长，删除Token

​	2. 与正常security项目流程一样，只不过需要在登录成功后的处理类中，使用Token管理类，生成token，存入redis数据库或其他地方，退出登录时的处理类或者退出登录成功后的处理类中，删除Token，以及redis数据库或者其他地方存有的Token