---
title: 报修系统详解
date: 2021-10-30 13:49:42
permalink: /rrs/details
categories:
  - 项目
  - 报修系统
tags: 
  - 
---

::: note
反规范的命名，唉。
:::


## 角色

审核员2名：审核订单的人。2名都审核通过才会通过

接单人多名：处理订单的人，一对一

申报人多名：报修的人，一般为学生

## 名词翻译

### 实体类简称

bxd：报修单

bxqy：报修区域

ewm：二维码

hc：耗材

jdr：接单人

qdb：签到表

shy：审核员

### 其他简称

yb：易班

xq：校区



### service类对象简称

bs：报修单的service类对象

es：二维码的service类对象

zdpd：自动派单的service类对象

ss：审核员的service类对象

qs：签到表的service类对象

js：接单人的service类对象

ybmsg：请求易班的service类对象



## 名词解释

标记的名词看不懂，这里有解释，都有标记



审核单：审核员要审核的订单

下班单：审核员下班了，但是还没来得及审核的订单。

::: note

问就是审核员不想加班，到点直接下班 :smile:

:::

返工天数：接单人处理完订单后，开始对该订单计时。类似于淘宝拿到快递后，却没有去app点击确认收货，但是一定时间后app会自动确认收货

## util包

### 类结构


其他99%不会被修改

```
config
|—— quartzUtils
	  |—— BxdCheckTask 
	  |—— FgAndPjTask
	  |—— OrderListener
	  |—— ShyCheck
├── AesTra
|── AutoOrder
├── DictItemTree
├── EwmUtil
├── GetInfo
├── GetSqlSession
├── Me
├── ParseUtil
├── PathUtil
├── RealMe
├── UnicodeEncode
```





### 内容

- `quartzUtils`包：都是定时任务执行的类

    - `BxdCheckTask `类：获取未派送的订单，将这些订单分配给有工时的接单人，并在易班推送消息给接单人
        - `executeBxdCheck`方法：获取未派送的订单，将这些订单分配给有工时的接单人，并在易班推送消息给接单人

    - `FgAndPjTask`类：<mark>返工天数</mark>减一以及15天后默认好评
        - `reduceFgts`方法：<mark>返工天数</mark>减1。用到两个mapper：一个是获取已完成的订单，一个是给这些完成订单的返工时间减1

        - `setPjnr`方法：15天后默认好评。用到两个mapper：一个获取已满15天却未验收的订单，一个是给这些未验收订单主动验收，并给好评

            ::: danger

            疑惑：怎么知道已满15天呢，我猜有定时任务，自动加1天吧，目前没看到，如果这条内容没有被删除，代表我没看到加1天的代码

            :::
    - `OrderListener`类：获取工时超过12的接单人的未处理的订单，交给其他人
        
        - `executeGsCheck`方法：当总订单派单工时已经超过12的接单人，他的其他订单重新派给未满12的接单人
    - `ShyCheck`类：获取<mark>下班单</mark>，随机分配给在上夜班的审核员进行审核
        - `executeShyCheck`：获取<mark>下班单</mark>，随机分配给在上夜班的审核员处进行审核

- `AesTra`类：加密解密类

    - `encrypt`方法：传入密钥和密码进行加密。目前没用到该方法
    - `decrypt`方法：传入密钥和密码进行解密。目前没用到该方法
    - `parseByte2HexStr`方法：位运算进行加密。由`encrypt`方法调用
    - `parseHexStr2Byte`方法：位运算进行解密。由`decrypt`方法调用

- `AutoOrder`类：处理派送订单类

    - `zdpd`方法：查找符合接单条件的接单人直接派单。条件：在职、工时小于12、在负责的区域里，当天签到了

- `DictItemTree`类：维修列表的实体类。存储如物业维修、热随维修、家电维修、空调维修等信息

    ::: danger

    疑惑：为什么放在utils目录下

    :::

- `EwmUtil`类：二维码工具类

    - `generateQRCodeImage`方法：生成二维码的条纹格式。用到的`BarcodeFormat.QR_CODE`枚举代表条纹格式的二维码

- `GetInfo`类：与易班进行授权，并获取登录用户的隐私信息（token）和普通信息（用户名，头像）和真实信息（真实姓名）

    - `init`方法：要求授权并获得token，将token存入`session`域里，如果授权失败，则返回登录页面继续授权

    - `getMe`方法：获取用户的基本信息，如用户名，头像，学校名等，存入`Me`实体类中。

        ::: warning

        项目里并没有用到这个方法！用到下面这个方法

        :::

    - `getRealMe`方法：在`getMe`方法上，多了一个实体类`RealMe`，它不仅封装了`Me`实体类，还有用户其他的真实信息如身份证。都存入session
    - `printError`方法：获取报错信息，存储session中，key为`message`

- `GetSqlSession`类：获取mybatis的`openSession`对象。

    ::: warning

    项目没有用到！

    :::

- `Me`类：用户信息的实体类，如昵称、性别、头像、学校等信息。主要存储与易班请求后得到数据的一个实体类。

- `ParseUtil`类：解析报修类型和耗材内容。大部分内容都在数据库的`bxd`表

    - `paraseBxlb`方法：参数为数字-数字。如2-2，3-1。根据数字获得不同的报修内容，最终返回的结果是报修类型-具体类型。如 物业报修-家具。

        ::: tip

        其实传来的参数是数字，解析后就是内容。数据库里已经规定一个数字代表一个内容

        :::

        ::: details 点击我查看数字对应的类型

        第一个数字：

        - 1：物业保修

        - 2：水电维修
        - 3：热水维修
        - 4：家电维修
        - 5：空调维修
        - 6：其他维修

        第二个数字：

        1：家具

        2：腻子

        3：墙砖

        ......

        具体数据库，第二个数字有60个左右

        :::

    - `paraseHc`方法：获取耗材的相关信息。和上面方法类似，解析分割传来的参数，获得不同的小参数，去数据库获取内容，具体看源码

    - `paraseHc1`方法：和`paraseHc`几乎一样，只不过返回结果前，多加了一个字符串作为标识符

    - `getzlb`方法：提供保修类型的英文，转化对应的中文，就是上方隐藏的内容

- `PathUtil`类：获取存放信息表格的路径，即s`tatic`所在的路径，分为生产和开发两个路径。前者是resource目录，后者是指定一个本地的文件夹

- `RealMe`类：`Me`类的封装实体类，在`Me`的基础上多加了一些用户的真实信息

- `UnicodeEncode`类：

    ::: danger

    不知道有何用处

    :::



### 优化

1. 命名要规范
2. `GetInfo`类的`getMe`方法和`getRealMe`方法合并
3. `Me`和`RealMe`和`DictItemTree`实体类不应该放在util目录下
4. `ParseUtil`类有switch，可尝试解构




## config包

### 结构

```
config
├── CrosConfig
|── QuartzConfiguration
├── RestTemplateConfig
├── Swagger2Config
```



### 内容

- `CrosConfig`类：解决跨域问题

- `QuartzConfiguration`类：定时任务。一共有4个定时任务。分别为

    1. `OrderListener`类的`executeGsCheck`方法：当总订单派单工时已经超过12的接单人，他的其他订单重新派给未满12的接单人

        > 每天9点-18点内 每隔20分钟 执行一次这个方法

    2. `ShyCheck`类的`executeShyCheck`方法：获取<mark>下班单</mark>，随机分配给在上夜班的审核员进行审核

        > 早上8点-早上10点 每隔15分钟 执行一次这个方法

        ::: danger

        有疑惑，既然获取下班单，那么应该是晚上的夜班才对，怎么是早上

        :::

    1. `BxdCheckTask`类的`executeBxdCheck`方法：处理没有派送的订单，让这些订单分配给空闲的<mark>接单人</mark>去处理。轮询查找

        > 早上9点-早上18点 每隔20分钟 执行一次

    2. `FgAndPjTask`类的`executeFgAndPjTask`：<mark>返工天数</mark>减一以及15天后默认好评

        > 每天凌晨 3:30 触发一次

- `RestTemplateConfig`类：将`RestTemplate`类放入IOC容器里，该类是restful风格的http。并给该http设置一些参数如请求超时时间，响应超时时间等，因为项目打算用`RestTemplate`来和易班进行请求。不可能无线请求下去，一定时间内易班不给数据，则撤回请求，并报错，存入日志

- `Swagger2Config`类：配置swagger，用于生成接口文档。指定了标题、描述、版本、作者、许可证等



## constant包

### 结构

```
constant
├── GlmcConstants
```

### 内容

- `GlmcConstants`类：桂林医学院报修系统的常量类。只有两个内容

    ```java
    /**
    * 总工时，单位：小时
     */
    public static final double GS = 12.0;
    public static final String HC_APPEND_SYMBOL = "=";
    ```

## exception包

### 结构

```
exception
├── GlobalExceptionHandler
```

### 内容

- `GlobalExceptionHandler`类：全局异常处理类。

    ::: note

    用到了`@ControllerAdvice`注解，指定哪些方法处理哪些异常

    :::



## filter包

### 结构

```
filter
├── AddResponseHeaderFilter
```

### 内容

- `AddResponseHeaderFilter`类：给响应头配置参数，如`UTF-8`，保证返回给前端的信息不乱码

    ::: note

    该类继承了`OncePerRequestFilter`类，表示能够确保在一次请求只通过一次filter，而不需要重复执行。

    其实在spring里，每个filter都默认继承OncePerRequestFilter

    :::



## response包

### 结构

```
response
├── ResponseData
```

### 内容

- `ResponseData`类：封装返回前端信息实体类，有状态码、信息数字、数据

    - 状态status：success、false

    - 信息数字info：
        - 0：未登录授权请登录，
        - 1：程序错误请刷新，
        - 2：无效参数，
        - 3：缺少传递必要参数
        - 其余的info就自己定义







## 学到的技巧

大部分学到的内容都在上方用 笔记蓝色框 标记了

- 如果对数据库进行批量的增删改。不要在Java代码里循环，然后调用mapper层。而是以集合的方式把所有参数传给mybatis，让mybatis进行遍历，即使用`forreach`标签
- `@ControllerAdvice` 注解实现全局异常处理
- `OncePerRequestFilter`的概念